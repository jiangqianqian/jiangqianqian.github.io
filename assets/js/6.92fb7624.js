(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{218:function(a,s,e){"use strict";e.r(s);var t=e(28),n=Object(t.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"async-await-的一些使用总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-await-的一些使用总结"}},[a._v("#")]),a._v(" async...await 的一些使用总结")]),a._v(" "),e("h2",{attrs:{id:"关于-async"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于-async"}},[a._v("#")]),a._v(" 关于 async")]),a._v(" "),e("p",[a._v("它会隐式返回一个 Promise 对象")]),a._v(" "),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async func () {\n  return 'a'\n}\n\n// 等价于\nfunc () {\n  return new Promise((resolve, reject) => {\n    resolve ('a')\n  })\n}\n")])])]),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async func () {\n  return new Promise(resolve, reject) => {\n    resolve ('a')\n  })\n\v}\n\n// 等价于\nfunc () {\n  let promise = return new Promise((resolve, reject) => {\n    resolve('a')\n  })\n  return new Promise((resolve) => resolve(promise))\n}\n")])])]),e("p",[a._v("async func 中有 return 'a', 等价于 func 中 new Promise 的 resolve('a')")]),a._v(" "),e("p",[a._v("async func 中有 throw Error('a'), 等价于 func 中 new Promise 的 reject('a')")]),a._v(" "),e("h2",{attrs:{id:"关于-await"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于-await"}},[a._v("#")]),a._v(" 关于 "),e("strong",[a._v("await")])]),a._v(" "),e("p",[a._v("await 后面跟的是 Promise 对象，如果不是，也会转换成 Promise 对象。")]),a._v(" "),e("p",[a._v("如 const res = await 'hello', 等价于 const res = await "),e("strong",[a._v("Promise.resolve")]),a._v("('hello')")]),a._v(" "),e("p",[a._v("try … catch() 中的 catch() 会捕获到 Promise 的异常，下面的代码是我经常使用的")]),a._v(" "),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async function func() {\n  try {\n    const res = await Promise.reject(30);\n  } catch (err) {\n    console.log(err); // 30\n  }\n}\n\nfunc();\n")])])]),e("p",[a._v("依次顺序执行异步操作")]),a._v(" "),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("// 先执行 task1，等 res1 有结果后，再执行 task2\nasync func () {\n  const res1 = await task1()\n  const res2 = await task2()\n}\n")])])]),e("p",[a._v("并行执行异步操作")]),a._v(" "),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("func () {\n  task1()\n  task2()\n  task3()\n}\n")])])]),e("p",[a._v("或者，")]),a._v(" "),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async func () {\n  const promise1 = task1()\n  const promise2 = task2()\n  const res1 = await promise1\n  const res2 = await promise2\n}\n")])])]),e("p",[a._v("或者，")]),a._v(" "),e("div",{staticClass:"language-(js) extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("async function func () {\n  await Promise.all([task1(), task2(),task3()])\n  console.log('三个任务执行完毕')\n  // 全部执行完毕后，接着后面的代码\n}\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);